module Cardano.Plutus.Sort where

import PlutusTx.Prelude
import PlutusTx
import PlutusTx.Builtins
import PlutusTx.List
import Control.Arrow ((&&&))
import GHC.Prim (seq)
import Cardano.Plutus.List
import Cardano.Plutus.Monad
import Data.These

-- |
-- > comparing p x y = compare (p x) (p y)
--
-- Useful combinator for use in conjunction with the @xxxBy@ family
-- of functions from "Data.List", for example:
--
-- >   ... sortBy (comparing fst) ...
{-# INLINABLE comparing #-}
comparing :: (Ord a) => (b -> a) -> b -> b -> Ordering
comparing p x y = compare (p x) (p y)

{-# INLINABLE monoidSortAssocsWith #-}
monoidSortAssocsWith :: (Monoid b, Ord k) => (a -> k) -> (a -> b) -> [a] -> [(k, b)]
monoidSortAssocsWith key val = monoidSortAssocs . map (key &&& val)


-- | Sort the list, agregating duplicates with the monoid and
-- ordering the elements by the items generated by the
-- argument function.
{-# INLINABLE monoidSortWith #-}
monoidSortWith :: (Monoid b, Ord k) => (a -> k) -> (a -> b) -> [a] -> [b]
-- monoidSortWith key val list = groupSortBy (comparing . key)
monoidSortWith key val = groupSortOn key $ const $ _monoidGroupWith val

-- Helper
{-# INLINABLE _monoidGroupWith #-}
_monoidGroupWith :: Monoid b => (a -> b) -> a -> [a] -> b
_monoidGroupWith val x xs = val x <> mconcat (map val xs)



-- ====================
-- https://hackage.haskell.org/package/sort-1.0.0.0/docs/src/Data-Sort.html

-- | Sort the list of associations, aggregating duplicates with the
-- monoid.
{-# INLINABLE monoidSortAssocs #-}
monoidSortAssocs :: (Monoid a,Ord k)
                 => [(k,a)]
                 -> [(k,a)]
monoidSortAssocs = monoidSortAssocsBy compare

-- | Sort the list of associations, aggregating duplicates with the
-- monoid and ordering the keys with the argument compare function.
{-# INLINABLE monoidSortAssocsBy #-}
monoidSortAssocsBy :: (Monoid a)
                   => (k->k->Ordering)
                   -> [(k,a)]
                   -> [(k,a)]
monoidSortAssocsBy cmp = groupSortAssocsBy cmp $ const monoid_group

-- | Sort the list of associations, aggregating duplicates with the
-- supplied function.
{-# INLINABLE groupSortAssocs #-}
groupSortAssocs :: Ord k
                => (k->a->[a]->b)
                -> [(k,a)]
                -> [(k,b)]
groupSortAssocs = groupSortAssocsBy compare

-- | Sort the list of associations, aggregating duplicates with the
-- supplied function and ordering the keys with the argument
-- compare function.
{-# INLINABLE groupSortAssocsBy #-}
groupSortAssocsBy :: (k->k->Ordering)
                  -> (k->a->[a]->b)
                  -> [(k,a)]
                  -> [(k,b)]
groupSortAssocsBy cmp0 grp0 = groupSortBy cmp grp
  where
    cmp (k,_) (k',_) = cmp0 k k'

    grp (k,y) ps     = (,) k $ grp0 k y $ map snd ps


-- | Sort the list, agregating duplicates with the monoid.
{-# INLINABLE monoidSort #-}
monoidSort :: (Monoid a,Ord a) => [a] -> [a]
monoidSort = monoidSortBy compare

-- | Sort the list, agregating duplicates with the monoid and
-- ordering the elements by the items generated by the
-- argument function.
{-# INLINABLE monoidSortOn #-}
monoidSortOn :: (Monoid a,Ord k) => (a->k) -> [a] -> [a]
monoidSortOn chg = groupSortOn chg $ const monoid_group

-- | Sort the list, agregating duplicates with the monoid
-- and ordering the keys with the argument compare function.
{-# INLINABLE monoidSortBy #-}
monoidSortBy :: Monoid a => (a->a->Ordering) -> [a] -> [a]
monoidSortBy cmp = groupSortBy cmp monoid_group


-- | Sort the list, discarding duplicates.
{-# INLINABLE uniqueSort #-}
uniqueSort :: Ord a => [a] -> [a]
uniqueSort = uniqueSortBy compare

-- | Sort the list, discarding duplicates and
-- ordering the elements by the items generated by the
-- argument function.
{-# INLINABLE uniqueSortOn #-}
uniqueSortOn :: Ord k => (a->k) -> [a] -> [a]
uniqueSortOn chg = groupSortOn chg $ const const

-- | Sort the list, discarding duplicates and ordering the keys with
-- the argument compare function.
{-# INLINABLE uniqueSortBy #-}
uniqueSortBy :: (a->a->Ordering) -> [a] -> [a]
uniqueSortBy cmp = groupSortBy cmp const


-- | Sort a list of elements with a stable sort, grouping together the
-- equal elements with the argument grouping function
{-# INLINABLE groupSort #-}
groupSort :: (Ord a) => (a->[a]->b) -> [a] -> [b]
groupSort = groupSortBy compare

-- | Sort a list of elements with a stable sort, using the argument
-- @compare@ function determine the ordering, grouping together the
-- equal elements with the grouping function
{-# INLINABLE groupSortOn #-}
groupSortOn :: Ord k
            => (a->k)
            -> (k->a->[a]->b)
            -> [a]
            -> [b]
groupSortOn chg grp = groupSortBy (comparing fst) grp_val . map inj
  where
    grp_val a as = grp k (snd a) $ map snd as
      where
        k = fst a

    inj x = k `seq` (k,x)
      where
        k = chg x


-- | Sort a list of elements with a stable sort, grouping together the
-- equal elements with the argument grouping function.
{-# INLINABLE groupSortBy #-}
groupSortBy :: (a->a->Ordering)
            -> (a->[a]->b)
            -> [a]
            -> [b]
groupSortBy cmp grp = aggregate . sortBy cmp
  where
    aggregate []    = []
    aggregate (h:t) = seq g $ g : aggregate rst
      where
        g         = grp h eqs
        (eqs,rst) = span is_le t

        is_le x   = case cmp x h of
          LT -> True
          EQ -> True
          GT -> False


-- the monoid_group helper

{-# INLINABLE monoid_group #-}
monoid_group :: Monoid a => a -> [a] -> a
monoid_group x xs = x <> mconcat xs

-- =====================

sortOn :: Ord b => (a -> b) -> [a] -> [a]
sortOn f =
  map snd . sortBy (comparing fst) . map (\x -> let y = f x in (y, x))

-- MergeSort
-- Sort a list of distinct items, or short-circuit to Nothing if duplicates found
{-# INLINABLE sortDistinct #-}
sortDistinct :: Ord a => [a] -> Maybe [a]
sortDistinct xs = sort' (length xs) xs
  where
    sort' _ [] = Just []
    sort' _ [x] = Just [x]
    sort' _ [x, y]
      | x < y = Just [x, y]
      | x > y = Just [y, x]
      | otherwise = Nothing
    sort' len xs = join $ liftA2 merge (sort' half left) (sort' (len - half) right)
      where
        half = len `divideInteger` 2
        (left, right) = splitAtWithLen half xs len
        merge xs [] = Just xs
        merge [] ys = Just ys
        merge (x:xs) (y:ys)
          | x < y = (Just . (x :)) =<< merge xs (y:ys)
          | x > y = (Just . (y :)) =<< merge (x:xs) ys
          | otherwise = Nothing

-- match corresponding elements in pairs, skipping missing elements with `Nothing`.
-- If multiple left elements correspond to one of the right elements or vice versa -
-- the first pair should have corresponding left and right elements,
-- and in the subsequent pairs the pair component should be `Nothing`.
{-# INLINE matchPairs #-}
matchPairs :: Ord a => (b -> a) -> [b] -> [b] -> [These b b]
matchPairs f xs ys = go (sortOn fst $ map (\x -> (f x, x)) xs) (sortOn fst $ map (\y -> (f y, y)) ys)
   where
      go [] ys' = map That (map snd ys')
      go xs' [] = map This (map snd xs')
      go ((xk, xl):xs') ((yk, yr):ys')
        | xk < yk  = This xl : go xs' ((yk, yr):ys')
        | xk > yk  = That yr : go ((xk, xl):xs') ys'
        | otherwise = These xl yr : go xs' ys'